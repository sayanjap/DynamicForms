{% extends 'examples/base.html' %}
{% block head_extra %}
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/axios@0.16.2/dist/axios.min.js" crossorigin="anonymous"></script>

  <style>
      th.ordering {
          cursor: pointer;
          user-select: none;
      }

      th.ordering > span.ordering > div.ordering-arrow {
          font-size: 125%;
      {# increase font size for the arrow #} line-height: .8em;
      {# but do not allow it to affect line size #} display: inline-block;
      }
  </style>
{% endblock %}
{% block title %}Render in template example{% endblock %}
{% block body %}

  <div id="app">
    {{ page_data }}
  </div>

  {% verbatim %}
  <script type="text/x-template" id="df-table-template">
    <table class="table">
      <thead is="df-table-header" :columns="columns" v-on:change-order="changeOrder"></thead>
      <tbody is="df-table-body" :columns="columns" :row-properties="rowProperties" :rows="rows"></tbody>
    </table>
  </script>

  <script type="text/x-template" id="df-table-header-template">
    <thead :key="renderSeq">
    <tr>  <!-- v-bind="properties" -->
      <th is="df-table-header-col" v-for="(col, idx) in columns" :key="col.name"
          :column="col" :col-idx="idx" :num-sorted-cols="numSortedCols"></th>
    </tr>
    </thead>
  </script>

  <script type="text/x-template" id="df-table-header-col-template">
    <th :style="`text-align: ${column.align}`" :class="column.th_classes" @click="colClicked($event)"
    >{{ column.label }}
      <span v-if="column.isOrdered" class="ordering"
      ><div class="ordering-arrow">{{ column.ascDescChar }}</div>{{ column.orderIndexChar }}</span>
    </th>
  </script>

  <script type="text/x-template" id="df-table-body-template">
    <tbody :key="renderSeq">
    <tr v-for="row in rows" :key="row['id']" :style="`${row['row_css_style']}`" v-bind="rowPropsWithData(row)">
      <td is="df-table-body-col" v-for="(col, idx) in columns" :key="col.name"
          :column="col" :col-idx="idx" :value="row[col.name]"></td>
    </tr>
    </tbody>
  </script>

  <script type="text/x-template" id="df-table-body-col-template">
    <td :style="`text-align: ${column.align}`">{{ value }}</td>
  </script>
  {% endverbatim %}

  <script>
    const DisplayMode = Object.freeze({
      // This enum is actually declared in dynamicforms.mixins.render.py
      SUPPRESS: 1,
      HIDDEN: 5,
      INVISIBLE: 8,
      FULL: 10,
    });

    class DFTableColumn {
      constructor(columnDef) {
        this._columnDef = columnDef;
      }

      get name() {
        return this._columnDef.name;
      }

      get label() {
        return this._columnDef.label;
      }

      get align() {
        return this._columnDef.align;
      }

      get table_classes() {
        return this._columnDef.table_classes;
      }

      get ordering() {
        return this._columnDef.ordering;
      }

      get visibility() {
        switch (this._columnDef.visibility) {
          case 1:
            return DisplayMode.SUPPRESS;
          case 5:
            return DisplayMode.HIDDEN;
          case 8:
            return DisplayMode.INVISIBLE;
          case 10:
            return DisplayMode.FULL;
          default:
            console.warn(`Table column came with visibility set to $(this._columnDef.visibility), but we don't know that constant`)
            return DisplayMode.FULL;
        }
      }

      get isOrdered() {
        return this.ordering.includes('ordering');
      }

      get th_classes() {
        return (this.table_classes + ' ' + (this.isOrdered ? 'ordering' : '')).trim()
      }

      get isAscending() {
        return this.isOrdered && this.ordering.includes('asc');
      }

      get isDescending() {
        return this.isOrdered && this.ordering.includes('desc');
      }

      get isUnsorted() {
        return this.isOrdered && this.ordering.includes('unsorted');
      }

      /**
       * cycles field ordering 'asc' -> 'desc' -> 'unsorted'
       */
      get cycleOrdering() {
        return this.isAscending ? 'desc' : this.isDescending ? 'unsorted' : 'asc';
      }

      /**
       * sets column sort sequence and direction
       * @param direction: one of "asc", "desc" or "unsorted"
       * @param sequence: integer. if none is provided, existing sequence # will be used or 1 if column was unsorted
       */
      setSorted(direction, sequence) {
        if (sequence === undefined)
          sequence = this.orderIndex > 0 ? this.orderIndex : 1

        if (!this.isOrdered) {
          console.warn(`column $(this.name) is not orderable. Why are you trying to set it's order direction?`)
        } else if (direction == 'asc' || direction == 'desc' || direction == 'unsorted') {
          this._columnDef.ordering = `ordering ${direction} ${direction == 'unsorted' ? '' : 'seg-' + sequence}`;
        } else {
          console.warn(`unknown sort direction "${direction}" for the column ${this.name}. not doing anything`);
        }
      }

      get ascDescChar() {
        if (!this.isOrdered) return '';
        else if (this.isAscending) return '\u25b2';
        else if (this.isDescending) return '\u25bc';
        else if (this.isUnsorted) return '\u2195';
        else return '';
      }

      get orderIndex() {
        if (!this.isOrdered) return 0;
        let ordrIdxMatch = /(?:seg-)(\d+)/.exec(this.ordering);
        return ordrIdxMatch != null ? Number(ordrIdxMatch[1]) : 0;
      }

      get orderIndexChar() {
        return this.orderIndex > 0 ? String.fromCharCode(0x2460 + this.orderIndex - 1) : '';
      }
    }

    Vue.component('df-table', {
      template: `#df-table-template`,
      props: ['url', 'data'],
      data() {
        const self = this;
        return {
          rows: self.data.rows == undefined || self.data.rows.constructor != Array ? [] : self.data.rows,
          columns: self.data.columns.map(c => new DFTableColumn(c)),
          rowProperties: self.data['row-properties'],
        };
      },
      computed: {
        sortedColumns() {
          // list of columns
          return this.columns.filter(col => col.isOrdered && !col.isUnsorted)
              .map(col => { return {fieldName: col.name, direction: col.isAscending, index: col.orderIndex}; })
              .sort((a, b) => a.index - b.index);
        },
        orderingParam() { return this.sortedColumns.map(o => (o.direction === true ? '' : '-') + o.fieldName); },
      },
      mounted() {},
      methods: {
        changeOrder(colIdx, sortDirection, sortSeq, clearAllOthers) {
          const orderChanged = this.columns[colIdx].orderIndex != sortSeq;
          this.columns.forEach(function (column, index) {
            if (index == colIdx) {
              column.setSorted(sortDirection, sortSeq);
            } else if (column.orderIndex > 0) {
              if (clearAllOthers) column.setSorted('unsorted');
              else if (orderChanged && column.orderIndex >= sortSeq) {
                column.setSorted(column.isAscending ? 'asc' : 'desc', column.orderIndex + 1);
              }
            }
          });
        },
        loadData() {
          const self = this;
          self.loading = true;
          axios.get(this.url + '?ordering=' + self.orderingParam).then(function(res) {
            // call api and set data as response, when data is set component is re-rendered
            self.rows = res.data;
          }).catch(function (err) { alert(err.data) })
              .then(function () { self.loading = false; });
        }
      },
      watch: {
        orderingParam(_newVal, _oldVal) {
          this.loadData();
        }
      }
    });
    Vue.component('df-table-header', {
      template: `#df-table-header-template`,
      props: ['columns'],
      data() {
        const self = this;
        // console.log({headerColumns: self.columns});
        return {
          renderSeq: 1,
        };
      },
      computed: {
        numSortedCols() { return this.columns.filter(col => col.ordering.includes('seg-')).length; },
      },
      mounted() {},
      methods: {},
    });
    Vue.component('df-table-header-col', {
      template: `#df-table-header-col-template`,
      props: ['column', 'colIdx', 'numSortedCols'],
      data() {
        return {};
      },
      computed: {},
      mounted() {},
      methods: {
        colClicked(event) {
          const self = this;

          if (!self.column.isOrdered)
              // don't do anything if this column is not sortable
            return;

          if (event.altKey) {
            // Show dialog with sort order options
          } else if (event.ctrlKey && event.shiftKey) {
            // remove column from ordering
            self.column.setSorted('unsorted');
          } else if (event.ctrlKey) {
            // set column as first sorted column
            self.$parent.$emit('change-order', self.colIdx, self.column.isDescending ? 'desc' : 'asc', 1);
          } else {
            // Change segment sort direction (and add it to sort segments list if not already there)
            // if shift is pressed add segment to existing ones. if not, set this column as the only segment of sort
            let ordrIdx = self.column.orderIndex,
                oSeq = event.shiftKey ? (ordrIdx == 0 ? self.numSortedCols + 1 : ordrIdx) : 1,
                oDir = event.shiftKey ? (self.column.isAscending ? 'desc' : 'asc') : self.column.cycleOrdering;
            self.$parent.$emit('change-order', self.colIdx, oDir, oSeq, !event.shiftKey);
          }
        },
      }
    });
    Vue.component('df-table-body', {
      template: `#df-table-body-template`,
      props: ['columns', 'rows', 'rowProperties'],
      data() {
        return {
          renderSeq: 1,
        };
      },
      computed: {},
      mounted() {},
      methods: {
        rowPropsWithData(row) {
          const self = this;
          let rp = this.rowProperties.reduce(function (obj, val) {
            obj['data-' + val] = row[val];
            return obj;
          }, {})
          delete rp['data-row_css_style'];
          return rp;
        }
      },
    });
    Vue.component('df-table-body-col', {
      template: `#df-table-body-col-template`,
      props: ['column', 'colIdx', 'value'],
      data() { return {}; },
      computed: {},
      mounted() {},
      methods: {},
    });

    const tableApp = new Vue({
      el: `#app`,
    });
  </script>

{% endblock %}